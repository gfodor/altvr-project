// Generated by CoffeeScript 1.5.0
(function() {
  var Root, t;

  t = THREE;

  Root = (function() {

    function Root(protocol, renderer, hud, userId, roomId) {
      this.protocol = protocol;
      this.renderer = renderer;
      this.hud = hud;
      this.userId = userId;
      this.roomId = roomId;
      this.Commands = this.protocol.build("Commands");
      this.Command = this.protocol.build("Command");
      this.PingCommand = this.protocol.build("Ping");
      this.CommandType = this.protocol.build("CommandType");
      this.Color = this.protocol.build("Color");
      this.pickedObject = null;
      this.drawState = U.DRAW_STATE_NONE;
      this.scene = new t.Scene();
      this.camera = new t.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      this.boards = [];
      this.clock = new t.Clock();
      this.controls = new t.PointerLockControls(this.camera);
      this.controls.enabled = false;
      this.scene.add(this.controls.getObject());
      this.setDrawColor(this.Color.BLACK);
    }

    Root.prototype.addBoard = function(board) {
      return this.boards.push(board);
    };

    Root.prototype.getBoard = function(boardId) {
      var board, _i, _len, _ref;
      _ref = this.boards;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        board = _ref[_i];
        if (board.id === boardId) {
          return board;
        }
      }
      return null;
    };

    Root.prototype.setDrawColor = function(drawColor) {
      this.drawColor = drawColor;
      return this.hud.setReticleColor(this.drawColor);
    };

    Root.prototype.connect = function() {
      var _this = this;
      this.socket = new WebSocket("ws://altvr.lulcards.com:8001/ws");
      this.socket.binaryType = "arraybuffer";
      window.pp = this.protocol;
      this.commandHandler = new CommandHandler(this);
      this.commandPump = new CommandPump(this.protocol, this.socket, this.commandHandler);
      this.commandGenerator = new CommandGenerator(this, this.protocol);
      this.socket.onopen = function() {
        var joinCommand;
        console.log("Connect");
        joinCommand = _this.commandGenerator.generateJoin();
        return _this.commandPump._send([joinCommand]);
      };
      this.socket.onclose = function() {
        return console.log("Disconnect");
      };
      return this.socket.onmessage = function(e) {
        var board, commands, _i, _len, _ref, _results;
        commands = _this.Commands.decode(e.data);
        _.each(commands.commands, function(c) {
          return _this.processIncomingCommand(c, commands.is_bootstrap);
        });
        _ref = _this.boards;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          board = _ref[_i];
          _results.push(board.refresh());
        }
        return _results;
      };
    };

    Root.prototype.processIncomingCommand = function(command, isBootstrap) {
      var requiresServer;
      switch (command.type) {
        case this.CommandType.PING:
          return this.processPing(command);
        default:
          requiresServer = U.requiresServerResponse(this.CommandType, command);
          if (isBootstrap || requiresServer || command.user_id !== this.userId) {
            return this.commandHandler.executeCommand(command);
          } else {

          }
      }
    };

    Root.prototype.processPing = function(command) {
      var pong;
      pong = new this.Command(command.type, this.userId, command.timestamp, this.roomId);
      pong.ping = new this.PingCommand(new Date().getTime());
      console.log("PING " + command.timestamp);
      return this.commandPump._send([pong]);
    };

    Root.prototype.render = function() {
      var U, b1, b2, b3, command, delta, isects, obj, projector, ray, self, u, uv, v, vertices, _ref;
      U = window.U;
      self = this;
      delta = this.clock.getDelta();
      this.controls.update(delta);
      projector = new t.Projector();
      ray = projector.pickingRay(new t.Vector3(0.0, 0.0, 0.0), this.camera);
      isects = ray.intersectObjects(_.map(this.boards, function(b) {
        return b.mesh;
      }), false);
      requestAnimationFrame((function() {
        return self.render();
      }));
      this.renderer.autoClear = true;
      this.renderer.render(this.scene, this.camera);
      this.pickedObject = null;
      if (isects.length > 0) {
        obj = isects[0].object;
        uv = obj.geometry.faceVertexUvs[0][isects[0].faceIndex];
        vertices = _.map(["a", "b", "c"], function(faceName) {
          var v;
          v = new t.Vector3();
          v.copy(obj.geometry.vertices[isects[0].face[faceName]]);
          obj.localToWorld(v);
          return v;
        });
        _ref = U.getBarycentricCoords(ray.ray, vertices[0], vertices[1], vertices[2]), b1 = _ref[0], b2 = _ref[1], b3 = _ref[2];
        u = b1 * uv[0].x + b2 * uv[1].x + b3 * uv[2].x;
        v = b1 * uv[0].y + b2 * uv[1].y + b3 * uv[2].y;
        this.pickedObject = {
          object: isects[0].object,
          u: u,
          v: 1.0 - v
        };
        if (this.drawState !== U.DRAW_STATE_NONE) {
          command = this.commandGenerator.generateDraw(this.pickedObject, this.drawState, this.drawColor);
          if (command) {
            this.commandPump.push(command, this.drawState !== U.DRAW_STATE_DURING);
          }
          if (this.drawState !== U.DRAW_STATE_END) {
            this.drawState = U.DRAW_STATE_DURING;
          } else {
            this.drawState = U.DRAW_STATE_NONE;
          }
        }
        this.renderer.autoClear = false;
        return this.renderer.render(this.hud.scene, this.hud.camera);
      } else {
        return this.pickedObject = null;
      }
    };

    Root.prototype.attachEvents = function() {
      var _this = this;
      this.setupPointerLockHandler();
      $(document).keypress(function(e) {
        return _this.handleKeyPress(e.which);
      });
      $(document).mousedown(function() {
        if (_this.isPointerLocked()) {
          return _this.drawState = U.DRAW_STATE_START;
        }
      });
      return $(document).mouseup(function() {
        if (_this.drawState !== U.DRAW_STATE_NONE) {
          return _this.drawState = U.DRAW_STATE_END;
        }
      });
    };

    Root.prototype.setupPointerLockHandler = function() {
      var pointerLockChangeHandler,
        _this = this;
      $(document).mousedown(function() {
        var element;
        if (!_this.isPointerLocked()) {
          element = $("body")[0];
          element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;
          return element.requestPointerLock();
        }
      });
      pointerLockChangeHandler = function() {
        return _this.controls.enabled = _this.isPointerLocked();
      };
      return _.each(["", "moz", "webkit"], function(prefix) {
        return document.addEventListener("" + prefix + "pointerlockchange", pointerLockChangeHandler, false);
      });
    };

    Root.prototype.isPointerLocked = function() {
      var el;
      el = $("body")[0];
      return document.pointerLockElement === el || document.mozPointerLockElement === el || document.webkitPointerLockElement === el;
    };

    Root.prototype.handleKeyPress = function(keyCode) {
      var board, colors, command, newDrawColor;
      switch (keyCode) {
        case 98:
          command = this.commandGenerator.generateCreateBoard();
          return this.commandPump.push(command, true);
        case 99:
          colors = [this.Color.BLACK, this.Color.RED, this.Color.GREEN, this.Color.BLUE];
          newDrawColor = colors[(_.indexOf(colors, this.drawColor) + 1) % colors.length];
          return this.setDrawColor(newDrawColor);
        case 101:
          console.log("hi");
          if (this.pickedObject && (this.pickedObject.object.__board != null)) {
            console.log(this.pickedObject);
            command = this.commandGenerator.generateErase();
            board = this.pickedObject.object.__board;
            command.board_id = board.id;
            return this.commandPump.push(command, true);
          }
      }
    };

    return Root;

  })();

  window.Root = Root;

}).call(this);
