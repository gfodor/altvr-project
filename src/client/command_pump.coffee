# The command pump provides a centralized channel which all commands must go 
# through. It sets two rate limits, the ENQUEUE_RATE_LIMIT limits which
# commands are applied to the game state. For example, when dragging on the 
# canvas we may generate a command every millisecond. The command pump only
# accepts one command every ENQUEUE_RATE_LIMIT milliseconds. (Unless the
# command is forced.)
#
# Additionally, the pump queues commands for a certain amount of time and
# flushes them in batch to the server, to be broadcast to the room.
#
# Finally, the pump will cause commands to get executed locally if they were 
# generated by the local session. 
class CommandPump
  ENQUEUE_RATE_LIMIT = 50
  FLUSH_RATE = 500

  constructor: (@protocol, @socket, @handler) ->
    @PingCommand = @protocol.build("Ping")
    @Commands = @protocol.build("Commands")
    @Command = @protocol.build("Command")
    @CommandType = @protocol.build("CommandType")
    @pendingCommands = []
    @lastEnqueueTime = 0
    @lastFlushTime = 0
    setInterval((=> this.flushIfReady()), 50)

  push: (command, force) ->
    now = (new Date()).getTime()

    # Enqueue it if we are seeing too many non-forced events (like cursor tracking)
    shouldEnqueue = force || (now - @lastEnqueueTime) > ENQUEUE_RATE_LIMIT

    if shouldEnqueue
      # Enqueue it for the server to receive it, and execute it locally
      @lastEnqueueTime = now
      @pendingCommands.push command

      unless U.requiresServerResponse(@CommandType, command)
        @handler.executeCommand command, true

    if force
      this.flush()
    else
      this.flushIfReady()

  flushIfReady: ->
    return unless @pendingCommands.length > 0

    if ((new Date()).getTime() - @lastFlushTime ) > FLUSH_RATE
      this.flush()

  flush: ->
    return unless @pendingCommands.length > 0
    return unless @socket.readyState == WebSocket.OPEN

    @lastFlushTime = (new Date()).getTime()
    this._send(@pendingCommands)
    @pendingCommands = []

  _send: (commands) ->
    if @socket.readyState == WebSocket.OPEN
      @socket.send((new @Commands(commands)).toArrayBuffer())

window.CommandPump = CommandPump
